'use strict';var _slicedToArray = function () {function sliceIterator(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"]) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}return function (arr, i) {if (Array.isArray(arr)) {return arr;} else if (Symbol.iterator in Object(arr)) {return sliceIterator(arr, i);} else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _path = require('path');var _path2 = _interopRequireDefault(_path);
var _fs = require('fs');var _fs2 = _interopRequireDefault(_fs);
var _pkgUp = require('eslint-module-utils/pkgUp');var _pkgUp2 = _interopRequireDefault(_pkgUp);
var _minimatch = require('minimatch');var _minimatch2 = _interopRequireDefault(_minimatch);
var _resolve = require('eslint-module-utils/resolve');var _resolve2 = _interopRequireDefault(_resolve);
var _moduleVisitor = require('eslint-module-utils/moduleVisitor');var _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);
var _importType = require('../core/importType');var _importType2 = _interopRequireDefault(_importType);
var _packagePath = require('../core/packagePath');
var _docsUrl = require('../docsUrl');var _docsUrl2 = _interopRequireDefault(_docsUrl);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { 'default': obj };}

var depFieldCache = new Map();

function hasKeys() {var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(obj).length > 0;
}

function arrayOrKeys(arrayOrObject) {
  return Array.isArray(arrayOrObject) ? arrayOrObject : Object.keys(arrayOrObject);
}

function readJSON(jsonPath, throwException) {
  try {
    return JSON.parse(_fs2['default'].readFileSync(jsonPath, 'utf8'));
  } catch (err) {
    if (throwException) {
      throw err;
    }
  }
}

function extractDepFields(pkg) {
  return {
    dependencies: pkg.dependencies || {},
    devDependencies: pkg.devDependencies || {},
    optionalDependencies: pkg.optionalDependencies || {},
    peerDependencies: pkg.peerDependencies || {},
    // BundledDeps should be in the form of an array, but object notation is also supported by
    // `npm`, so we convert it to an array if it is an object
    bundledDependencies: arrayOrKeys(pkg.bundleDependencies || pkg.bundledDependencies || []) };

}

function getPackageDepFields(packageJsonPath, throwAtRead) {
  if (!depFieldCache.has(packageJsonPath)) {
    var depFields = extractDepFields(readJSON(packageJsonPath, throwAtRead));
    depFieldCache.set(packageJsonPath, depFields);
  }

  return depFieldCache.get(packageJsonPath);
}

function getDependencies(context, packageDir) {
  var paths = [];
  try {
    var packageContent = {
      dependencies: {},
      devDependencies: {},
      optionalDependencies: {},
      peerDependencies: {},
      bundledDependencies: [] };


    if (packageDir && packageDir.length > 0) {
      if (!Array.isArray(packageDir)) {
        paths = [_path2['default'].resolve(packageDir)];
      } else {
        paths = packageDir.map(function (dir) {return _path2['default'].resolve(dir);});
      }
    }

    if (paths.length > 0) {
      // use rule config to find package.json
      paths.forEach(function (dir) {
        var packageJsonPath = _path2['default'].join(dir, 'package.json');
        var _packageContent = getPackageDepFields(packageJsonPath, true);
        Object.keys(packageContent).forEach(function (depsKey) {return (
            Object.assign(packageContent[depsKey], _packageContent[depsKey]));});

      });
    } else {
      var packageJsonPath = (0, _pkgUp2['default'])({
        cwd: context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename(),
        normalize: false });


      // use closest package.json
      Object.assign(
      packageContent,
      getPackageDepFields(packageJsonPath, false));

    }

    if (![
    packageContent.dependencies,
    packageContent.devDependencies,
    packageContent.optionalDependencies,
    packageContent.peerDependencies,
    packageContent.bundledDependencies].
    some(hasKeys)) {
      return null;
    }

    return packageContent;
  } catch (e) {
    if (paths.length > 0 && e.code === 'ENOENT') {
      context.report({
        message: 'The package.json file could not be found.',
        loc: { line: 0, column: 0 } });

    }
    if (e.name === 'JSONError' || e instanceof SyntaxError) {
      context.report({
        message: 'The package.json file could not be parsed: ' + e.message,
        loc: { line: 0, column: 0 } });

    }

    return null;
  }
}

function missingErrorMessage(packageName) {
  return '\'' + String(packageName) + '\' should be listed in the project\'s dependencies. ' + ('Run \'npm i -S ' + String(
  packageName) + '\' to add it');
}

function devDepErrorMessage(packageName) {
  return '\'' + String(packageName) + '\' should be listed in the project\'s dependencies, not devDependencies.';
}

function optDepErrorMessage(packageName) {
  return '\'' + String(packageName) + '\' should be listed in the project\'s dependencies, ' + 'not optionalDependencies.';

}

function getModuleOriginalName(name) {var _name$split =
  name.split('/'),_name$split2 = _slicedToArray(_name$split, 2),first = _name$split2[0],second = _name$split2[1];
  return first.startsWith('@') ? String(first) + '/' + String(second) : first;
}

function getModuleRealName(resolved) {
  return (0, _packagePath.getFilePackageName)(resolved);
}

function checkDependencyDeclaration(deps, packageName, declarationStatus) {
  var newDeclarationStatus = declarationStatus || {
    isInDeps: false,
    isInDevDeps: false,
    isInOptDeps: false,
    isInPeerDeps: false,
    isInBundledDeps: false };


  // in case of sub package.json inside a module
  // check the dependencies on all hierarchy
  var packageHierarchy = [];
  var packageNameParts = packageName ? packageName.split('/') : [];
  packageNameParts.forEach(function (namePart, index) {
    if (!namePart.startsWith('@')) {
      var ancestor = packageNameParts.slice(0, index + 1).join('/');
      packageHierarchy.push(ancestor);
    }
  });

  return packageHierarchy.reduce(function (result, ancestorName) {
    return {
      isInDeps: result.isInDeps || deps.dependencies[ancestorName] !== undefined,
      isInDevDeps: result.isInDevDeps || deps.devDependencies[ancestorName] !== undefined,
      isInOptDeps: result.isInOptDeps || deps.optionalDependencies[ancestorName] !== undefined,
      isInPeerDeps: result.isInPeerDeps || deps.peerDependencies[ancestorName] !== undefined,
      isInBundledDeps:
      result.isInBundledDeps || deps.bundledDependencies.indexOf(ancestorName) !== -1 };

  }, newDeclarationStatus);
}

function reportIfMissing(context, deps, depsOptions, node, name) {
  // Do not report when importing types unless option is enabled
  if (
  !depsOptions.verifyTypeImports && (
  node.importKind === 'type' || node.importKind === 'typeof'))
  {
    return;
  }

  var typeOfImport = (0, _importType2['default'])(name, context);

  if (
  typeOfImport !== 'external' && (
  typeOfImport !== 'internal' || !depsOptions.verifyInternalDeps))
  {
    return;
  }

  var resolved = (0, _resolve2['default'])(name, context);
  if (!resolved) {return;}

  var importPackageName = getModuleOriginalName(name);
  var declarationStatus = checkDependencyDeclaration(deps, importPackageName);

  if (
  declarationStatus.isInDeps ||
  depsOptions.allowDevDeps && declarationStatus.isInDevDeps ||
  depsOptions.allowPeerDeps && declarationStatus.isInPeerDeps ||
  depsOptions.allowOptDeps && declarationStatus.isInOptDeps ||
  depsOptions.allowBundledDeps && declarationStatus.isInBundledDeps)
  {
    return;
  }

  // test the real name from the resolved package.json
  // if not aliased imports (alias/react for example), importPackageName can be misinterpreted
  var realPackageName = getModuleRealName(resolved);
  if (realPackageName && realPackageName !== importPackageName) {
    declarationStatus = checkDependencyDeclaration(deps, realPackageName, declarationStatus);

    if (
    declarationStatus.isInDeps ||
    depsOptions.allowDevDeps && declarationStatus.isInDevDeps ||
    depsOptions.allowPeerDeps && declarationStatus.isInPeerDeps ||
    depsOptions.allowOptDeps && declarationStatus.isInOptDeps ||
    depsOptions.allowBundledDeps && declarationStatus.isInBundledDeps)
    {
      return;
    }
  }

  if (declarationStatus.isInDevDeps && !depsOptions.allowDevDeps) {
    context.report(node, devDepErrorMessage(realPackageName || importPackageName));
    return;
  }

  if (declarationStatus.isInOptDeps && !depsOptions.allowOptDeps) {
    context.report(node, optDepErrorMessage(realPackageName || importPackageName));
    return;
  }

  context.report(node, missingErrorMessage(realPackageName || importPackageName));
}

function testConfig(config, filename) {
  // Simplest configuration first, either a boolean or nothing.
  if (typeof config === 'boolean' || typeof config === 'undefined') {
    return config;
  }
  // Array of globs.
  return config.some(function (c) {return (
      (0, _minimatch2['default'])(filename, c) ||
      (0, _minimatch2['default'])(filename, _path2['default'].join(process.cwd(), c)));});

}

module.exports = {
  meta: {
    type: 'problem',
    docs: {
      category: 'Helpful warnings',
      description: 'Forbid the use of extraneous packages.',
      url: (0, _docsUrl2['default'])('no-extraneous-dependencies') },


    schema: [
    {
      'type': 'object',
      'properties': {
        'devDependencies': { 'type': ['boolean', 'array'] },
        'optionalDependencies': { 'type': ['boolean', 'array'] },
        'peerDependencies': { 'type': ['boolean', 'array'] },
        'bundledDependencies': { 'type': ['boolean', 'array'] },
        'packageDir': { 'type': ['string', 'array'] },
        'includeInternal': { 'type': ['boolean'] },
        'includeTypes': { 'type': ['boolean'] } },

      'additionalProperties': false }] },




  create: function () {function create(context) {
      var options = context.options[0] || {};
      var filename = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();
      var deps = getDependencies(context, options.packageDir) || extractDepFields({});

      var depsOptions = {
        allowDevDeps: testConfig(options.devDependencies, filename) !== false,
        allowOptDeps: testConfig(options.optionalDependencies, filename) !== false,
        allowPeerDeps: testConfig(options.peerDependencies, filename) !== false,
        allowBundledDeps: testConfig(options.bundledDependencies, filename) !== false,
        verifyInternalDeps: !!options.includeInternal,
        verifyTypeImports: !!options.includeTypes };


      return (0, _moduleVisitor2['default'])(function (source, node) {
        reportIfMissing(context, deps, depsOptions, node, source.value);
      }, { commonjs: true });
    }return create;}(),

  'Program:exit': function () {function ProgramExit() {
      depFieldCache.clear();
    }return ProgramExit;}() };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcy5qcyJdLCJuYW1lcyI6WyJkZXBGaWVsZENhY2hlIiwiTWFwIiwiaGFzS2V5cyIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJhcnJheU9yS2V5cyIsImFycmF5T3JPYmplY3QiLCJBcnJheSIsImlzQXJyYXkiLCJyZWFkSlNPTiIsImpzb25QYXRoIiwidGhyb3dFeGNlcHRpb24iLCJKU09OIiwicGFyc2UiLCJmcyIsInJlYWRGaWxlU3luYyIsImVyciIsImV4dHJhY3REZXBGaWVsZHMiLCJwa2ciLCJkZXBlbmRlbmNpZXMiLCJkZXZEZXBlbmRlbmNpZXMiLCJvcHRpb25hbERlcGVuZGVuY2llcyIsInBlZXJEZXBlbmRlbmNpZXMiLCJidW5kbGVkRGVwZW5kZW5jaWVzIiwiYnVuZGxlRGVwZW5kZW5jaWVzIiwiZ2V0UGFja2FnZURlcEZpZWxkcyIsInBhY2thZ2VKc29uUGF0aCIsInRocm93QXRSZWFkIiwiaGFzIiwiZGVwRmllbGRzIiwic2V0IiwiZ2V0IiwiZ2V0RGVwZW5kZW5jaWVzIiwiY29udGV4dCIsInBhY2thZ2VEaXIiLCJwYXRocyIsInBhY2thZ2VDb250ZW50IiwicGF0aCIsInJlc29sdmUiLCJtYXAiLCJkaXIiLCJmb3JFYWNoIiwiam9pbiIsIl9wYWNrYWdlQ29udGVudCIsImFzc2lnbiIsImRlcHNLZXkiLCJjd2QiLCJnZXRQaHlzaWNhbEZpbGVuYW1lIiwiZ2V0RmlsZW5hbWUiLCJub3JtYWxpemUiLCJzb21lIiwiZSIsImNvZGUiLCJyZXBvcnQiLCJtZXNzYWdlIiwibG9jIiwibGluZSIsImNvbHVtbiIsIm5hbWUiLCJTeW50YXhFcnJvciIsIm1pc3NpbmdFcnJvck1lc3NhZ2UiLCJwYWNrYWdlTmFtZSIsImRldkRlcEVycm9yTWVzc2FnZSIsIm9wdERlcEVycm9yTWVzc2FnZSIsImdldE1vZHVsZU9yaWdpbmFsTmFtZSIsInNwbGl0IiwiZmlyc3QiLCJzZWNvbmQiLCJzdGFydHNXaXRoIiwiZ2V0TW9kdWxlUmVhbE5hbWUiLCJyZXNvbHZlZCIsImNoZWNrRGVwZW5kZW5jeURlY2xhcmF0aW9uIiwiZGVwcyIsImRlY2xhcmF0aW9uU3RhdHVzIiwibmV3RGVjbGFyYXRpb25TdGF0dXMiLCJpc0luRGVwcyIsImlzSW5EZXZEZXBzIiwiaXNJbk9wdERlcHMiLCJpc0luUGVlckRlcHMiLCJpc0luQnVuZGxlZERlcHMiLCJwYWNrYWdlSGllcmFyY2h5IiwicGFja2FnZU5hbWVQYXJ0cyIsIm5hbWVQYXJ0IiwiaW5kZXgiLCJhbmNlc3RvciIsInNsaWNlIiwicHVzaCIsInJlZHVjZSIsInJlc3VsdCIsImFuY2VzdG9yTmFtZSIsInVuZGVmaW5lZCIsImluZGV4T2YiLCJyZXBvcnRJZk1pc3NpbmciLCJkZXBzT3B0aW9ucyIsIm5vZGUiLCJ2ZXJpZnlUeXBlSW1wb3J0cyIsImltcG9ydEtpbmQiLCJ0eXBlT2ZJbXBvcnQiLCJ2ZXJpZnlJbnRlcm5hbERlcHMiLCJpbXBvcnRQYWNrYWdlTmFtZSIsImFsbG93RGV2RGVwcyIsImFsbG93UGVlckRlcHMiLCJhbGxvd09wdERlcHMiLCJhbGxvd0J1bmRsZWREZXBzIiwicmVhbFBhY2thZ2VOYW1lIiwidGVzdENvbmZpZyIsImNvbmZpZyIsImZpbGVuYW1lIiwiYyIsInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwibWV0YSIsInR5cGUiLCJkb2NzIiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsInVybCIsInNjaGVtYSIsImNyZWF0ZSIsIm9wdGlvbnMiLCJpbmNsdWRlSW50ZXJuYWwiLCJpbmNsdWRlVHlwZXMiLCJzb3VyY2UiLCJ2YWx1ZSIsImNvbW1vbmpzIiwiY2xlYXIiXSwibWFwcGluZ3MiOiJxb0JBQUEsNEI7QUFDQSx3QjtBQUNBLGtEO0FBQ0Esc0M7QUFDQSxzRDtBQUNBLGtFO0FBQ0EsZ0Q7QUFDQTtBQUNBLHFDOztBQUVBLElBQU1BLGdCQUFnQixJQUFJQyxHQUFKLEVBQXRCOztBQUVBLFNBQVND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b0JBQWNnSSxLQUFkO0FBQ0QsS0FGRCxzQkE3Q2UsRUFBakIiLCJmaWxlIjoibm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHBrZ1VwIGZyb20gJ2VzbGludC1tb2R1bGUtdXRpbHMvcGtnVXAnO1xyXG5pbXBvcnQgbWluaW1hdGNoIGZyb20gJ21pbmltYXRjaCc7XHJcbmltcG9ydCByZXNvbHZlIGZyb20gJ2VzbGludC1tb2R1bGUtdXRpbHMvcmVzb2x2ZSc7XHJcbmltcG9ydCBtb2R1bGVWaXNpdG9yIGZyb20gJ2VzbGludC1tb2R1bGUtdXRpbHMvbW9kdWxlVmlzaXRvcic7XHJcbmltcG9ydCBpbXBvcnRUeXBlIGZyb20gJy4uL2NvcmUvaW1wb3J0VHlwZSc7XHJcbmltcG9ydCB7IGdldEZpbGVQYWNrYWdlTmFtZSB9IGZyb20gJy4uL2NvcmUvcGFja2FnZVBhdGgnO1xyXG5pbXBvcnQgZG9jc1VybCBmcm9tICcuLi9kb2NzVXJsJztcclxuXHJcbmNvbnN0IGRlcEZpZWxkQ2FjaGUgPSBuZXcgTWFwKCk7XHJcblxyXG5mdW5jdGlvbiBoYXNLZXlzKG9iaiA9IHt9KSB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlPcktleXMoYXJyYXlPck9iamVjdCkge1xyXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFycmF5T3JPYmplY3QpID8gYXJyYXlPck9iamVjdCA6IE9iamVjdC5rZXlzKGFycmF5T3JPYmplY3QpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkSlNPTihqc29uUGF0aCwgdGhyb3dFeGNlcHRpb24pIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGpzb25QYXRoLCAndXRmOCcpKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGlmICh0aHJvd0V4Y2VwdGlvbikge1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBleHRyYWN0RGVwRmllbGRzKHBrZykge1xyXG4gIHJldHVybiB7XHJcbiAgICBkZXBlbmRlbmNpZXM6IHBrZy5kZXBlbmRlbmNpZXMgfHwge30sXHJcbiAgICBkZXZEZXBlbmRlbmNpZXM6IHBrZy5kZXZEZXBlbmRlbmNpZXMgfHwge30sXHJcbiAgICBvcHRpb25hbERlcGVuZGVuY2llczogcGtnLm9wdGlvbmFsRGVwZW5kZW5jaWVzIHx8IHt9LFxyXG4gICAgcGVlckRlcGVuZGVuY2llczogcGtnLnBlZXJEZXBlbmRlbmNpZXMgfHwge30sXHJcbiAgICAvLyBCdW5kbGVkRGVwcyBzaG91bGQgYmUgaW4gdGhlIGZvcm0gb2YgYW4gYXJyYXksIGJ1dCBvYmplY3Qgbm90YXRpb24gaXMgYWxzbyBzdXBwb3J0ZWQgYnlcclxuICAgIC8vIGBucG1gLCBzbyB3ZSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IGlmIGl0IGlzIGFuIG9iamVjdFxyXG4gICAgYnVuZGxlZERlcGVuZGVuY2llczogYXJyYXlPcktleXMocGtnLmJ1bmRsZURlcGVuZGVuY2llcyB8fCBwa2cuYnVuZGxlZERlcGVuZGVuY2llcyB8fCBbXSksXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UGFja2FnZURlcEZpZWxkcyhwYWNrYWdlSnNvblBhdGgsIHRocm93QXRSZWFkKSB7XHJcbiAgaWYgKCFkZXBGaWVsZENhY2hlLmhhcyhwYWNrYWdlSnNvblBhdGgpKSB7XHJcbiAgICBjb25zdCBkZXBGaWVsZHMgPSBleHRyYWN0RGVwRmllbGRzKHJlYWRKU09OKHBhY2thZ2VKc29uUGF0aCwgdGhyb3dBdFJlYWQpKTtcclxuICAgIGRlcEZpZWxkQ2FjaGUuc2V0KHBhY2thZ2VKc29uUGF0aCwgZGVwRmllbGRzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkZXBGaWVsZENhY2hlLmdldChwYWNrYWdlSnNvblBhdGgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoY29udGV4dCwgcGFja2FnZURpcikge1xyXG4gIGxldCBwYXRocyA9IFtdO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYWNrYWdlQ29udGVudCA9IHtcclxuICAgICAgZGVwZW5kZW5jaWVzOiB7fSxcclxuICAgICAgZGV2RGVwZW5kZW5jaWVzOiB7fSxcclxuICAgICAgb3B0aW9uYWxEZXBlbmRlbmNpZXM6IHt9LFxyXG4gICAgICBwZWVyRGVwZW5kZW5jaWVzOiB7fSxcclxuICAgICAgYnVuZGxlZERlcGVuZGVuY2llczogW10sXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChwYWNrYWdlRGlyICYmIHBhY2thZ2VEaXIubGVuZ3RoID4gMCkge1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFja2FnZURpcikpIHtcclxuICAgICAgICBwYXRocyA9IFtwYXRoLnJlc29sdmUocGFja2FnZURpcildO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhdGhzID0gcGFja2FnZURpci5tYXAoZGlyID0+IHBhdGgucmVzb2x2ZShkaXIpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXRocy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIHVzZSBydWxlIGNvbmZpZyB0byBmaW5kIHBhY2thZ2UuanNvblxyXG4gICAgICBwYXRocy5mb3JFYWNoKGRpciA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcGF0aC5qb2luKGRpciwgJ3BhY2thZ2UuanNvbicpO1xyXG4gICAgICAgIGNvbnN0IF9wYWNrYWdlQ29udGVudCA9IGdldFBhY2thZ2VEZXBGaWVsZHMocGFja2FnZUpzb25QYXRoLCB0cnVlKTtcclxuICAgICAgICBPYmplY3Qua2V5cyhwYWNrYWdlQ29udGVudCkuZm9yRWFjaChkZXBzS2V5ID0+XHJcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHBhY2thZ2VDb250ZW50W2RlcHNLZXldLCBfcGFja2FnZUNvbnRlbnRbZGVwc0tleV0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcGtnVXAoe1xyXG4gICAgICAgIGN3ZDogY29udGV4dC5nZXRQaHlzaWNhbEZpbGVuYW1lID8gY29udGV4dC5nZXRQaHlzaWNhbEZpbGVuYW1lKCkgOiBjb250ZXh0LmdldEZpbGVuYW1lKCksXHJcbiAgICAgICAgbm9ybWFsaXplOiBmYWxzZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyB1c2UgY2xvc2VzdCBwYWNrYWdlLmpzb25cclxuICAgICAgT2JqZWN0LmFzc2lnbihcclxuICAgICAgICBwYWNrYWdlQ29udGVudCxcclxuICAgICAgICBnZXRQYWNrYWdlRGVwRmllbGRzKHBhY2thZ2VKc29uUGF0aCwgZmFsc2UpLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghW1xyXG4gICAgICBwYWNrYWdlQ29udGVudC5kZXBlbmRlbmNpZXMsXHJcbiAgICAgIHBhY2thZ2VDb250ZW50LmRldkRlcGVuZGVuY2llcyxcclxuICAgICAgcGFja2FnZUNvbnRlbnQub3B0aW9uYWxEZXBlbmRlbmNpZXMsXHJcbiAgICAgIHBhY2thZ2VDb250ZW50LnBlZXJEZXBlbmRlbmNpZXMsXHJcbiAgICAgIHBhY2thZ2VDb250ZW50LmJ1bmRsZWREZXBlbmRlbmNpZXMsXHJcbiAgICBdLnNvbWUoaGFzS2V5cykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhY2thZ2VDb250ZW50O1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmIChwYXRocy5sZW5ndGggPiAwICYmIGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcclxuICAgICAgY29udGV4dC5yZXBvcnQoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgcGFja2FnZS5qc29uIGZpbGUgY291bGQgbm90IGJlIGZvdW5kLicsXHJcbiAgICAgICAgbG9jOiB7IGxpbmU6IDAsIGNvbHVtbjogMCB9LFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChlLm5hbWUgPT09ICdKU09ORXJyb3InIHx8IGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xyXG4gICAgICBjb250ZXh0LnJlcG9ydCh7XHJcbiAgICAgICAgbWVzc2FnZTogJ1RoZSBwYWNrYWdlLmpzb24gZmlsZSBjb3VsZCBub3QgYmUgcGFyc2VkOiAnICsgZS5tZXNzYWdlLFxyXG4gICAgICAgIGxvYzogeyBsaW5lOiAwLCBjb2x1bW46IDAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtaXNzaW5nRXJyb3JNZXNzYWdlKHBhY2thZ2VOYW1lKSB7XHJcbiAgcmV0dXJuIGAnJHtwYWNrYWdlTmFtZX0nIHNob3VsZCBiZSBsaXN0ZWQgaW4gdGhlIHByb2plY3QncyBkZXBlbmRlbmNpZXMuIGAgK1xyXG4gICAgYFJ1biAnbnBtIGkgLVMgJHtwYWNrYWdlTmFtZX0nIHRvIGFkZCBpdGA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRldkRlcEVycm9yTWVzc2FnZShwYWNrYWdlTmFtZSkge1xyXG4gIHJldHVybiBgJyR7cGFja2FnZU5hbWV9JyBzaG91bGQgYmUgbGlzdGVkIGluIHRoZSBwcm9qZWN0J3MgZGVwZW5kZW5jaWVzLCBub3QgZGV2RGVwZW5kZW5jaWVzLmA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wdERlcEVycm9yTWVzc2FnZShwYWNrYWdlTmFtZSkge1xyXG4gIHJldHVybiBgJyR7cGFja2FnZU5hbWV9JyBzaG91bGQgYmUgbGlzdGVkIGluIHRoZSBwcm9qZWN0J3MgZGVwZW5kZW5jaWVzLCBgICtcclxuICAgIGBub3Qgb3B0aW9uYWxEZXBlbmRlbmNpZXMuYDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TW9kdWxlT3JpZ2luYWxOYW1lKG5hbWUpIHtcclxuICBjb25zdCBbZmlyc3QsIHNlY29uZF0gPSBuYW1lLnNwbGl0KCcvJyk7XHJcbiAgcmV0dXJuIGZpcnN0LnN0YXJ0c1dpdGgoJ0AnKSA/IGAke2ZpcnN0fS8ke3NlY29uZH1gIDogZmlyc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1vZHVsZVJlYWxOYW1lKHJlc29sdmVkKSB7XHJcbiAgcmV0dXJuIGdldEZpbGVQYWNrYWdlTmFtZShyZXNvbHZlZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrRGVwZW5kZW5jeURlY2xhcmF0aW9uKGRlcHMsIHBhY2thZ2VOYW1lLCBkZWNsYXJhdGlvblN0YXR1cykge1xyXG4gIGNvbnN0IG5ld0RlY2xhcmF0aW9uU3RhdHVzID0gZGVjbGFyYXRpb25TdGF0dXMgfHwge1xyXG4gICAgaXNJbkRlcHM6IGZhbHNlLFxyXG4gICAgaXNJbkRldkRlcHM6IGZhbHNlLFxyXG4gICAgaXNJbk9wdERlcHM6IGZhbHNlLFxyXG4gICAgaXNJblBlZXJEZXBzOiBmYWxzZSxcclxuICAgIGlzSW5CdW5kbGVkRGVwczogZmFsc2UsXHJcbiAgfTtcclxuXHJcbiAgLy8gaW4gY2FzZSBvZiBzdWIgcGFja2FnZS5qc29uIGluc2lkZSBhIG1vZHVsZVxyXG4gIC8vIGNoZWNrIHRoZSBkZXBlbmRlbmNpZXMgb24gYWxsIGhpZXJhcmNoeVxyXG4gIGNvbnN0IHBhY2thZ2VIaWVyYXJjaHkgPSBbXTtcclxuICBjb25zdCBwYWNrYWdlTmFtZVBhcnRzID0gcGFja2FnZU5hbWUgPyBwYWNrYWdlTmFtZS5zcGxpdCgnLycpIDogW107XHJcbiAgcGFja2FnZU5hbWVQYXJ0cy5mb3JFYWNoKChuYW1lUGFydCwgaW5kZXgpID0+IHtcclxuICAgIGlmICghbmFtZVBhcnQuc3RhcnRzV2l0aCgnQCcpKSB7XHJcbiAgICAgIGNvbnN0IGFuY2VzdG9yID0gcGFja2FnZU5hbWVQYXJ0cy5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4oJy8nKTtcclxuICAgICAgcGFja2FnZUhpZXJhcmNoeS5wdXNoKGFuY2VzdG9yKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHBhY2thZ2VIaWVyYXJjaHkucmVkdWNlKChyZXN1bHQsIGFuY2VzdG9yTmFtZSkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNJbkRlcHM6IHJlc3VsdC5pc0luRGVwcyB8fCBkZXBzLmRlcGVuZGVuY2llc1thbmNlc3Rvck5hbWVdICE9PSB1bmRlZmluZWQsXHJcbiAgICAgIGlzSW5EZXZEZXBzOiByZXN1bHQuaXNJbkRldkRlcHMgfHwgZGVwcy5kZXZEZXBlbmRlbmNpZXNbYW5jZXN0b3JOYW1lXSAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICBpc0luT3B0RGVwczogcmVzdWx0LmlzSW5PcHREZXBzIHx8IGRlcHMub3B0aW9uYWxEZXBlbmRlbmNpZXNbYW5jZXN0b3JOYW1lXSAhPT0gdW5kZWZpbmVkLFxyXG4gICAgICBpc0luUGVlckRlcHM6IHJlc3VsdC5pc0luUGVlckRlcHMgfHwgZGVwcy5wZWVyRGVwZW5kZW5jaWVzW2FuY2VzdG9yTmFtZV0gIT09IHVuZGVmaW5lZCxcclxuICAgICAgaXNJbkJ1bmRsZWREZXBzOlxyXG4gICAgICAgIHJlc3VsdC5pc0luQnVuZGxlZERlcHMgfHwgZGVwcy5idW5kbGVkRGVwZW5kZW5jaWVzLmluZGV4T2YoYW5jZXN0b3JOYW1lKSAhPT0gLTEsXHJcbiAgICB9O1xyXG4gIH0sIG5ld0RlY2xhcmF0aW9uU3RhdHVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVwb3J0SWZNaXNzaW5nKGNvbnRleHQsIGRlcHMsIGRlcHNPcHRpb25zLCBub2RlLCBuYW1lKSB7XHJcbiAgLy8gRG8gbm90IHJlcG9ydCB3aGVuIGltcG9ydGluZyB0eXBlcyB1bmxlc3Mgb3B0aW9uIGlzIGVuYWJsZWRcclxuICBpZiAoXHJcbiAgICAhZGVwc09wdGlvbnMudmVyaWZ5VHlwZUltcG9ydHMgJiZcclxuICAgIChub2RlLmltcG9ydEtpbmQgPT09ICd0eXBlJyB8fCBub2RlLmltcG9ydEtpbmQgPT09ICd0eXBlb2YnKVxyXG4gICkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHlwZU9mSW1wb3J0ID0gaW1wb3J0VHlwZShuYW1lLCBjb250ZXh0KTtcclxuXHJcbiAgaWYgKFxyXG4gICAgdHlwZU9mSW1wb3J0ICE9PSAnZXh0ZXJuYWwnXHJcbiAgICAmJiAodHlwZU9mSW1wb3J0ICE9PSAnaW50ZXJuYWwnIHx8ICFkZXBzT3B0aW9ucy52ZXJpZnlJbnRlcm5hbERlcHMpXHJcbiAgKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmUobmFtZSwgY29udGV4dCk7XHJcbiAgaWYgKCFyZXNvbHZlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgY29uc3QgaW1wb3J0UGFja2FnZU5hbWUgPSBnZXRNb2R1bGVPcmlnaW5hbE5hbWUobmFtZSk7XHJcbiAgbGV0IGRlY2xhcmF0aW9uU3RhdHVzID0gY2hlY2tEZXBlbmRlbmN5RGVjbGFyYXRpb24oZGVwcywgaW1wb3J0UGFja2FnZU5hbWUpO1xyXG5cclxuICBpZiAoXHJcbiAgICBkZWNsYXJhdGlvblN0YXR1cy5pc0luRGVwcyB8fFxyXG4gICAgKGRlcHNPcHRpb25zLmFsbG93RGV2RGVwcyAmJiBkZWNsYXJhdGlvblN0YXR1cy5pc0luRGV2RGVwcykgfHxcclxuICAgIChkZXBzT3B0aW9ucy5hbGxvd1BlZXJEZXBzICYmIGRlY2xhcmF0aW9uU3RhdHVzLmlzSW5QZWVyRGVwcykgfHxcclxuICAgIChkZXBzT3B0aW9ucy5hbGxvd09wdERlcHMgJiYgZGVjbGFyYXRpb25TdGF0dXMuaXNJbk9wdERlcHMpIHx8XHJcbiAgICAoZGVwc09wdGlvbnMuYWxsb3dCdW5kbGVkRGVwcyAmJiBkZWNsYXJhdGlvblN0YXR1cy5pc0luQnVuZGxlZERlcHMpXHJcbiAgKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyB0ZXN0IHRoZSByZWFsIG5hbWUgZnJvbSB0aGUgcmVzb2x2ZWQgcGFja2FnZS5qc29uXHJcbiAgLy8gaWYgbm90IGFsaWFzZWQgaW1wb3J0cyAoYWxpYXMvcmVhY3QgZm9yIGV4YW1wbGUpLCBpbXBvcnRQYWNrYWdlTmFtZSBjYW4gYmUgbWlzaW50ZXJwcmV0ZWRcclxuICBjb25zdCByZWFsUGFja2FnZU5hbWUgPSBnZXRNb2R1bGVSZWFsTmFtZShyZXNvbHZlZCk7XHJcbiAgaWYgKHJlYWxQYWNrYWdlTmFtZSAmJiByZWFsUGFja2FnZU5hbWUgIT09IGltcG9ydFBhY2thZ2VOYW1lKSB7XHJcbiAgICBkZWNsYXJhdGlvblN0YXR1cyA9IGNoZWNrRGVwZW5kZW5jeURlY2xhcmF0aW9uKGRlcHMsIHJlYWxQYWNrYWdlTmFtZSwgZGVjbGFyYXRpb25TdGF0dXMpO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgZGVjbGFyYXRpb25TdGF0dXMuaXNJbkRlcHMgfHxcclxuICAgICAgKGRlcHNPcHRpb25zLmFsbG93RGV2RGVwcyAmJiBkZWNsYXJhdGlvblN0YXR1cy5pc0luRGV2RGVwcykgfHxcclxuICAgICAgKGRlcHNPcHRpb25zLmFsbG93UGVlckRlcHMgJiYgZGVjbGFyYXRpb25TdGF0dXMuaXNJblBlZXJEZXBzKSB8fFxyXG4gICAgICAoZGVwc09wdGlvbnMuYWxsb3dPcHREZXBzICYmIGRlY2xhcmF0aW9uU3RhdHVzLmlzSW5PcHREZXBzKSB8fFxyXG4gICAgICAoZGVwc09wdGlvbnMuYWxsb3dCdW5kbGVkRGVwcyAmJiBkZWNsYXJhdGlvblN0YXR1cy5pc0luQnVuZGxlZERlcHMpXHJcbiAgICApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGRlY2xhcmF0aW9uU3RhdHVzLmlzSW5EZXZEZXBzICYmICFkZXBzT3B0aW9ucy5hbGxvd0RldkRlcHMpIHtcclxuICAgIGNvbnRleHQucmVwb3J0KG5vZGUsIGRldkRlcEVycm9yTWVzc2FnZShyZWFsUGFja2FnZU5hbWUgfHwgaW1wb3J0UGFja2FnZU5hbWUpKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChkZWNsYXJhdGlvblN0YXR1cy5pc0luT3B0RGVwcyAmJiAhZGVwc09wdGlvbnMuYWxsb3dPcHREZXBzKSB7XHJcbiAgICBjb250ZXh0LnJlcG9ydChub2RlLCBvcHREZXBFcnJvck1lc3NhZ2UocmVhbFBhY2thZ2VOYW1lIHx8IGltcG9ydFBhY2thZ2VOYW1lKSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb250ZXh0LnJlcG9ydChub2RlLCBtaXNzaW5nRXJyb3JNZXNzYWdlKHJlYWxQYWNrYWdlTmFtZSB8fCBpbXBvcnRQYWNrYWdlTmFtZSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0ZXN0Q29uZmlnKGNvbmZpZywgZmlsZW5hbWUpIHtcclxuICAvLyBTaW1wbGVzdCBjb25maWd1cmF0aW9uIGZpcnN0LCBlaXRoZXIgYSBib29sZWFuIG9yIG5vdGhpbmcuXHJcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIGNvbmZpZztcclxuICB9XHJcbiAgLy8gQXJyYXkgb2YgZ2xvYnMuXHJcbiAgcmV0dXJuIGNvbmZpZy5zb21lKGMgPT4gKFxyXG4gICAgbWluaW1hdGNoKGZpbGVuYW1lLCBjKSB8fFxyXG4gICAgbWluaW1hdGNoKGZpbGVuYW1lLCBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgYykpXHJcbiAgKSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIG1ldGE6IHtcclxuICAgIHR5cGU6ICdwcm9ibGVtJyxcclxuICAgIGRvY3M6IHtcclxuICAgICAgY2F0ZWdvcnk6ICdIZWxwZnVsIHdhcm5pbmdzJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdGb3JiaWQgdGhlIHVzZSBvZiBleHRyYW5lb3VzIHBhY2thZ2VzLicsXHJcbiAgICAgIHVybDogZG9jc1VybCgnbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMnKSxcclxuICAgIH0sXHJcblxyXG4gICAgc2NoZW1hOiBbXHJcbiAgICAgIHtcclxuICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxyXG4gICAgICAgICdwcm9wZXJ0aWVzJzoge1xyXG4gICAgICAgICAgJ2RldkRlcGVuZGVuY2llcyc6IHsgJ3R5cGUnOiBbJ2Jvb2xlYW4nLCAnYXJyYXknXSB9LFxyXG4gICAgICAgICAgJ29wdGlvbmFsRGVwZW5kZW5jaWVzJzogeyAndHlwZSc6IFsnYm9vbGVhbicsICdhcnJheSddIH0sXHJcbiAgICAgICAgICAncGVlckRlcGVuZGVuY2llcyc6IHsgJ3R5cGUnOiBbJ2Jvb2xlYW4nLCAnYXJyYXknXSB9LFxyXG4gICAgICAgICAgJ2J1bmRsZWREZXBlbmRlbmNpZXMnOiB7ICd0eXBlJzogWydib29sZWFuJywgJ2FycmF5J10gfSxcclxuICAgICAgICAgICdwYWNrYWdlRGlyJzogeyAndHlwZSc6IFsnc3RyaW5nJywgJ2FycmF5J10gfSxcclxuICAgICAgICAgICdpbmNsdWRlSW50ZXJuYWwnOiB7ICd0eXBlJzogWydib29sZWFuJ10gfSxcclxuICAgICAgICAgICdpbmNsdWRlVHlwZXMnOiB7ICd0eXBlJzogWydib29sZWFuJ10gfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICB9LFxyXG5cclxuICBjcmVhdGUoY29udGV4dCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9uc1swXSB8fCB7fTtcclxuICAgIGNvbnN0IGZpbGVuYW1lID0gY29udGV4dC5nZXRQaHlzaWNhbEZpbGVuYW1lID8gY29udGV4dC5nZXRQaHlzaWNhbEZpbGVuYW1lKCkgOiBjb250ZXh0LmdldEZpbGVuYW1lKCk7XHJcbiAgICBjb25zdCBkZXBzID0gZ2V0RGVwZW5kZW5jaWVzKGNvbnRleHQsIG9wdGlvbnMucGFja2FnZURpcikgfHwgZXh0cmFjdERlcEZpZWxkcyh7fSk7XHJcblxyXG4gICAgY29uc3QgZGVwc09wdGlvbnMgPSB7XHJcbiAgICAgIGFsbG93RGV2RGVwczogdGVzdENvbmZpZyhvcHRpb25zLmRldkRlcGVuZGVuY2llcywgZmlsZW5hbWUpICE9PSBmYWxzZSxcclxuICAgICAgYWxsb3dPcHREZXBzOiB0ZXN0Q29uZmlnKG9wdGlvbnMub3B0aW9uYWxEZXBlbmRlbmNpZXMsIGZpbGVuYW1lKSAhPT0gZmFsc2UsXHJcbiAgICAgIGFsbG93UGVlckRlcHM6IHRlc3RDb25maWcob3B0aW9ucy5wZWVyRGVwZW5kZW5jaWVzLCBmaWxlbmFtZSkgIT09IGZhbHNlLFxyXG4gICAgICBhbGxvd0J1bmRsZWREZXBzOiB0ZXN0Q29uZmlnKG9wdGlvbnMuYnVuZGxlZERlcGVuZGVuY2llcywgZmlsZW5hbWUpICE9PSBmYWxzZSxcclxuICAgICAgdmVyaWZ5SW50ZXJuYWxEZXBzOiAhIW9wdGlvbnMuaW5jbHVkZUludGVybmFsLFxyXG4gICAgICB2ZXJpZnlUeXBlSW1wb3J0czogISFvcHRpb25zLmluY2x1ZGVUeXBlcyxcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIG1vZHVsZVZpc2l0b3IoKHNvdXJjZSwgbm9kZSkgPT4ge1xyXG4gICAgICByZXBvcnRJZk1pc3NpbmcoY29udGV4dCwgZGVwcywgZGVwc09wdGlvbnMsIG5vZGUsIHNvdXJjZS52YWx1ZSk7XHJcbiAgICB9LCB7IGNvbW1vbmpzOiB0cnVlIH0pO1xyXG4gIH0sXHJcblxyXG4gICdQcm9ncmFtOmV4aXQnOiAoKSA9PiB7XHJcbiAgICBkZXBGaWVsZENhY2hlLmNsZWFyKCk7XHJcbiAgfSxcclxufTtcclxuIl19